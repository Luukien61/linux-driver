# minfs TODO 2: Completing minfs Superblock

## üìã M·ª•c ti√™u
Ho√†n th√†nh vi·ªác ƒë·ªçc v√† kh·ªüi t·∫°o superblock cho minfs filesystem ƒë·ªÉ c√≥ th·ªÉ mount ƒë∆∞·ª£c filesystem.

## üéØ Y√™u c·∫ßu
- ƒê·ªçc superblock t·ª´ disk (block ƒë·∫ßu ti√™n - index 0)
- Validate magic number ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng filesystem type
- Kh·ªüi t·∫°o VFS superblock structure
- T·∫°o root inode s·ª≠ d·ª•ng `myfs_get_inode` (temporary solution)
- Filesystem c√≥ th·ªÉ mount ƒë∆∞·ª£c nh∆∞ng ch∆∞a th·ªÉ th·ª±c hi·ªán c√°c thao t√°c kh√°c (ƒë√¢y l√† ƒëi·ªÅu b√¨nh th∆∞·ªùng)

## üîß Build v√† Setup

### Build kernel module:
```bash
# Trong th∆∞ m·ª•c ch·ª©a source code
make build

# Ki·ªÉm tra file .ko ƒë√£ ƒë∆∞·ª£c t·∫°o
ls -la /home/root/skels/filesystems/minfs/kernel/minfs.ko
```

### T·∫°o filesystem tr√™n device:
```bash
# S·ª≠ d·ª•ng mkfs.minfs ƒë·ªÉ format device
/home/root/skels/filesystems/minfs/user/mkfs.minfs /dev/vdc

# mkfs.minfs s·∫Ω:
# - T·∫°o superblock ·ªü block 0
# - T·∫°o inode table ·ªü block 1  
# - Kh·ªüi t·∫°o root directory
# - Set up filesystem structures
```

## üíª Implementation Chi Ti·∫øt

### 1. Forward Declaration
```c
/* Forward declaration for myfs_get_inode */
static struct inode *myfs_get_inode(struct super_block *sb, const struct inode *dir, umode_t mode);
```
**Gi·∫£i th√≠ch:**
- C·∫ßn declare function tr∆∞·ªõc khi s·ª≠ d·ª•ng trong C
- `myfs_get_inode` ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü cu·ªëi file nh∆∞ng s·ª≠ d·ª•ng trong `minfs_fill_super`
- `static` c√≥ nghƒ©a function ch·ªâ visible trong file n√†y

### 2. ƒê·ªçc Superblock t·ª´ Disk
```c
/* TODO 2: Read block with superblock. It's the first block on
 * the device, i.e. the block with the index 0. This is the index
 * to be passed to sb_bread().
 */
bh = sb_bread(s, 0);
if (!bh) {
    printk(LOG_LEVEL "unable to read superblock\n");
    goto out_bad_sb;
}
```
**Gi·∫£i th√≠ch t·ª´ng d√≤ng:**
- `sb_bread(s, 0)`: ƒê·ªçc block 0 t·ª´ device ƒë∆∞·ª£c mount
    - `s`: pointer ƒë·∫øn VFS superblock structure
    - `0`: block number (superblock lu√¥n ·ªü block ƒë·∫ßu ti√™n)
    - Tr·∫£ v·ªÅ `buffer_head` pointer ho·∫∑c NULL n·∫øu l·ªói
- `if (!bh)`: Ki·ªÉm tra l·ªói ƒë·ªçc
- `printk()`: In th√¥ng b√°o l·ªói v√†o kernel log (dmesg)
- `goto out_bad_sb`: Jump ƒë·∫øn error handling code ƒë·ªÉ cleanup

### 3. Parse v√† Validate Superblock
```c
/* TODO 2: interpret read data as minfs_super_block */
ms = (struct minfs_super_block *)bh->b_data;

/* TODO 2: check magic number with value defined in minfs.h */
if (ms->magic != MINFS_MAGIC) {
    printk(LOG_LEVEL "wrong magic number\n");
    goto out_bad_magic;
}
```
**Gi·∫£i th√≠ch chi ti·∫øt:**
- `bh->b_data`: Raw data c·ªßa block ƒë√£ ƒë·ªçc (void pointer)
- `(struct minfs_super_block *)`: Cast sang struct ƒë·ªÉ access c√°c fields
- `ms->magic`: Access magic number field t·ª´ superblock
- `MINFS_MAGIC`: Constant ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong `minfs.h` (v√≠ d·ª•: 0x4d494e46)
- Magic number validation ƒë·∫£m b·∫£o device th·ª±c s·ª± ch·ª©a minfs filesystem

### 4. Kh·ªüi t·∫°o VFS Superblock
```c
/* TODO 2: fill super_block with magic_number, super_operations */
s->s_magic = MINFS_MAGIC;
s->s_op = &minfs_ops;
```
**Gi·∫£i th√≠ch:**
- `s->s_magic`: Set magic number cho VFS superblock
- `s->s_op`: G√°n pointer ƒë·∫øn operations structure
- `minfs_ops`: ƒê√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc ƒë√≥, ch·ª©a c√°c function pointers:
  ```c
  static const struct super_operations minfs_ops = {
      .statfs     = simple_statfs,
      .put_super  = minfs_put_super,
      // TODO 3 s·∫Ω th√™m alloc_inode v√† destroy_inode
  };
  ```

### 5. L∆∞u Filesystem-specific Information
```c
/* TODO 2: Fill sbi with rest of information from disk superblock
 * (i.e. version).
 */
sbi->version = ms->version;
sbi->imap = ms->imap;
```
**Gi·∫£i th√≠ch:**
- `sbi`: `minfs_sb_info` structure - ch·ª©a th√¥ng tin ri√™ng c·ªßa minfs
- `ms->version`: Version c·ªßa filesystem t·ª´ disk
- `ms->imap`: Inode bitmap t·ª´ disk - theo d√µi inode n√†o ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng
- Th√¥ng tin n√†y kh√¥ng c√≥ trong VFS superblock n√™n ph·∫£i l∆∞u ri√™ng

### 6. T·∫°o Root Inode
```c
/* TODO 2: use myfs_get_inode instead of minfs_iget */
root_inode = myfs_get_inode(s, NULL, S_IFDIR | 0755);
if (!root_inode)
    goto out_bad_inode;

root_dentry = d_make_root(root_inode);
if (!root_dentry)
    goto out_iput;
s->s_root = root_dentry;
```
**Gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc:**
- `myfs_get_inode(s, NULL, S_IFDIR | 0755)`:
    - `s`: superblock
    - `NULL`: parent inode (root kh√¥ng c√≥ parent)
    - `S_IFDIR | 0755`: file type (directory) + permissions (rwxr-xr-x)
- `d_make_root(root_inode)`: T·∫°o root dentry t·ª´ inode
- `s->s_root = root_dentry`: Set root dentry cho filesystem

### 7. myfs_get_inode Implementation (Temporary)
```c
static struct inode *myfs_get_inode(struct super_block *sb, const struct inode *dir, umode_t mode)
{
    struct inode *inode = new_inode(sb);
    
    if (!inode)
        return NULL;

    inode->i_ino = get_next_ino();
    inode_init_owner(inode, dir, mode);
    inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);

    switch (mode & S_IFMT) {
    case S_IFDIR:
        inode->i_op = &simple_dir_inode_operations;
        inode->i_fop = &simple_dir_operations;
        inc_nlink(inode);
        break;
    case S_IFREG:
        inode->i_op = &simple_file_inode_operations;
        inode->i_fop = &simple_file_operations;
        break;
    }

    return inode;
}
```
**Gi·∫£i th√≠ch t·ª´ng ph·∫ßn:**
- `new_inode(sb)`: Allocate VFS inode structure
- `get_next_ino()`: T·∫°o unique inode number (temporary)
- `inode_init_owner()`: Set owner, group, permissions
- `current_time()`: Set timestamps
- `mode & S_IFMT`: Extract file type t·ª´ mode
- `simple_dir_*`: Use kernel's simple filesystem operations (temporary)
- `inc_nlink()`: TƒÉng link count cho directory (directories start with 2 links)

## üèóÔ∏è Structures v√† Constants

### minfs_super_block (On-disk format)
```c
struct minfs_super_block {
    __u32 magic;           // 0x4d494e46 - "MINF" 
    __u8 version;          // Filesystem version
    unsigned long imap;    // Inode bitmap
    // ƒê∆∞·ª£c ƒë·ªçc t·ª´ block 0 c·ªßa device
};
```

### minfs_sb_info (In-memory format)
```c
struct minfs_sb_info {
    __u8 version;               // Copy t·ª´ disk
    unsigned long imap;         // Copy t·ª´ disk
    struct buffer_head *sbh;    // Reference ƒë·∫øn superblock buffer
    // ƒê∆∞·ª£c l∆∞u trong s->s_fs_info
};
```

### Constants trong minfs.h
```c
#define MINFS_MAGIC     0x4d494e46  // Magic number
#define MINFS_BLOCK_SIZE    4096    // Block size
#define MINFS_ROOT_INODE    0       // Root inode number
```

## üß™ Testing Chi Ti·∫øt

### Step 1: Load Module
```bash
# Load kernel module
root@qemux86:~# insmod /home/root/skels/filesystems/minfs/kernel/minfs.ko

# Ki·ªÉm tra module ƒë√£ load
root@qemux86:~# lsmod | grep minfs
minfs                  16384  0

# Ki·ªÉm tra kernel messages
root@qemux86:~# dmesg | tail -5
[ 1234.567890] minfs: loading out-of-tree module taints kernel.
```

### Step 2: Check Filesystem Registration
```bash
# Ki·ªÉm tra filesystem ƒë√£ ƒë∆∞·ª£c register
root@qemux86:~# cat /proc/filesystems | grep minfs
        minfs

# minfs xu·∫•t hi·ªán trong danh s√°ch -> registration th√†nh c√¥ng
```

### Step 3: Create Filesystem
```bash
# Format device v·ªõi minfs
root@qemux86:~# /home/root/skels/filesystems/minfs/user/mkfs.minfs /dev/vdc

# mkfs.minfs s·∫Ω:
# 1. Write superblock to block 0
# 2. Initialize inode table at block 1  
# 3. Create root directory structure
```

### Step 4: Mount Filesystem
```bash
# T·∫°o mount point
root@qemux86:~# mkdir -p /mnt/minfs

# Mount filesystem
root@qemux86:~# mount -t minfs /dev/vdc /mnt/minfs

# Kh√¥ng c√≥ error message = mount th√†nh c√¥ng!
```

### Step 5: Verify Mount
```bash
# Ki·ªÉm tra mount
root@qemux86:~# mount | grep minfs
/dev/vdc on /mnt/minfs type minfs (rw,relatime)

# Ki·ªÉm tra disk usage
root@qemux86:~# df /mnt/minfs
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/vdc            1024     0      1024   0% /mnt/minfs
```

## ‚úÖ K·∫øt Qu·∫£ Mong ƒê·ª£i

### Th√†nh c√¥ng:
- ‚úÖ **Mount successful**: Kh√¥ng c√≥ error message
- ‚úÖ **Filesystem registered**: Xu·∫•t hi·ªán trong `/proc/filesystems`
- ‚úÖ **Superblock validation**: Magic number ƒë∆∞·ª£c ki·ªÉm tra ƒë√∫ng
- ‚úÖ **Root inode created**: Filesystem c√≥ root directory

### S·∫Ω l·ªói (ƒë√¢y l√† b√¨nh th∆∞·ªùng):
- ‚ùå **`ls /mnt/minfs`**: L·ªói v√¨ `minfs_readdir` ch∆∞a implement (TODO 5)
- ‚ùå **`touch /mnt/minfs/file`**: L·ªói v√¨ `minfs_create` ch∆∞a implement (TODO 7)
- ‚ùå **`mkdir /mnt/minfs/dir`**: L·ªói v√¨ directory operations ch∆∞a ho√†n ch·ªânh

### Test commands s·∫Ω l·ªói:
```bash
# S·∫Ω b√°o l·ªói ho·∫∑c kh√¥ng hi·ªÉn th·ªã g√¨
root@qemux86:~# ls /mnt/minfs
ls: /mnt/minfs: Function not implemented

# S·∫Ω b√°o l·ªói
root@qemux86:~# touch /mnt/minfs/testfile  
touch: /mnt/minfs/testfile: Function not implemented
```

## üîß Debugging Tips

### Ki·ªÉm tra kernel logs:
```bash
# Xem kernel messages
dmesg | grep minfs

# Xem live kernel messages  
dmesg -w
```

### Common errors v√† solutions:
1. **"wrong magic number"**: Device ch∆∞a ƒë∆∞·ª£c format v·ªõi mkfs.minfs
2. **"unable to read superblock"**: Device kh√¥ng t·ªìn t·∫°i ho·∫∑c permission issue
3. **"bad inode"**: myfs_get_inode function c√≥ l·ªói

## üìÅ Files Modified

### minfs.c changes:
1. **Added forward declaration** cho `myfs_get_inode`
2. **Completed TODO 2** trong `minfs_fill_super()`:
    - ƒê·ªçc superblock t·ª´ disk
    - Validate magic number
    - Initialize VFS superblock
    - Copy filesystem-specific info
3. **Added myfs_get_inode()** function (temporary)

### Build artifacts:
- `minfs.ko`: Kernel module file
- `Module.symvers`: Symbol version info
- `modules.order`: Module dependency order

## üöÄ Next Steps

Sau khi ho√†n th√†nh TODO 2, c√°c TODO ti·∫øp theo s·∫Ω l√†m:

- **TODO 3**: Implement `alloc_inode` v√† `destroy_inode` trong `minfs_ops`
- **TODO 4**: Ho√†n thi·ªán `minfs_iget` ƒë·ªÉ ƒë·ªçc inode t·ª´ disk thay v√¨ t·∫°o in-memory
- **TODO 5**: Implement `minfs_readdir` ƒë·ªÉ `ls` command ho·∫°t ƒë·ªông
- **TODO 6**: Implement `minfs_lookup` ƒë·ªÉ t√¨m ki·∫øm files
- **TODO 7**: Implement file creation (`minfs_create`) ƒë·ªÉ `touch` command ho·∫°t ƒë·ªông

## üìù Notes Quan Tr·ªçng

- **`myfs_get_inode` ch·ªâ l√† temporary**: T·∫°o in-memory inode, kh√¥ng ƒë·ªçc t·ª´ disk
- **Simple operations ƒë∆∞·ª£c s·ª≠ d·ª•ng**: `simple_dir_operations`, `simple_file_operations`
- **Error handling ƒë·∫ßy ƒë·ªß**: M·ªçi l·ªói ƒë·ªÅu ƒë∆∞·ª£c handle v·ªõi goto labels
- **Buffer management**: `bh` ƒë∆∞·ª£c release trong error paths
- **Superblock buffer ƒë∆∞·ª£c l∆∞u**: `sbi->sbh` ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y